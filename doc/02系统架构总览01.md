
基于当前项目的代码结构和实现，我为你总结了文字冒险游戏的业务流程和架构。以下是详细分析：

## 🏗️ 系统架构总览

**第一个图**展示了系统的**分层架构**，包含5个核心层次：
```mermaid
graph TB
    subgraph "用户交互层"
        A[main.py<br/>主程序入口] --> B[UserInterface<br/>用户交互模块]
        B --> B1[显示场景]
        B --> B2[显示选项]
        B --> B3[获取输入]
        B --> B4[输入校验]
    end
    
    subgraph "游戏逻辑层"
        C[GameEngine<br/>游戏引擎] --> C1[AI生成模式]
        C --> C2[预设故事模式]
        C1 --> C3[事件推进]
        C1 --> C4[状态变化处理]
        C1 --> C5[随机事件]
        C2 --> C6[预设剧情分支]
    end
    
    subgraph "状态管理层"
        D[GameStateManager<br/>状态管理器] --> D1[Player<br/>玩家模型]
        D --> D2[StoryState<br/>剧情状态]
        D --> D3[存档系统]
        D1 --> D4[属性管理]
        D1 --> D5[背包系统]
        D1 --> D6[经验升级]
        D2 --> D7[场景历史]
        D2 --> D8[故事标记]
        D2 --> D9[分支统计]
    end
    
    subgraph "AI生成层"
        E[ScenePrompt<br/>场景生成] --> E1[场景描述生成]
        E --> E2[角色对话生成]
        E --> E3[选项生成]
        E --> E4[事件推进生成]
        E1 --> F[Ollama<br/>本地大模型]
        E2 --> F
        E3 --> F
        E4 --> F
    end
    
    subgraph "数据存储层"
        G[JSON存档文件] --> G1[玩家数据]
        G --> G2[剧情状态]
        G --> G3[游戏元数据]
    end
    
    %% 业务流程连接
    A --> C
    A --> D
    C --> E
    C --> D
    D --> G
    
    %% 数据流向
    B -.->|玩家输入| C
    C -.->|游戏状态| B
    C -.->|AI生成请求| E
    E -.->|生成内容| C
    C -.->|状态更新| D
    D -.->|存档操作| G
```
### 1. 用户交互层
- **UserInterface**: 负责命令行界面的输入输出
- **main.py**: 程序入口，控制主菜单和游戏循环

### 2. 游戏逻辑层  
- **GameEngine**: 核心游戏引擎，支持AI生成和预设两种模式
- 处理玩家输入，生成故事内容，管理游戏流程

### 3. 状态管理层
- **GameStateManager**: 统一管理游戏状态
- **Player**: 玩家属性、背包、经验系统
- **StoryState**: 剧情状态、历史记录、故事标记

### 4. AI生成层
- **ScenePrompt**: 四种专业提示词模板
- **Ollama**: 本地大语言模型服务

### 5. 数据存储层
- JSON格式的存档文件系统

## 🔄 业务流程时序

**第二个图**展示了完整的**游戏运行时序**：
```mermaid
sequenceDiagram
    participant U as 用户
    participant UI as UserInterface
    participant M as main.py
    participant GE as GameEngine
    participant SM as StateManager
    participant SP as ScenePrompt
    participant O as Ollama模型
    
    Note over U,O: 游戏启动流程
    U->>M: 启动游戏
    M->>UI: 显示主菜单
    UI->>U: 选择：新游戏/继续游戏
    U->>UI: 选择新游戏
    UI->>SM: 创建新游戏
    SM->>GE: 启动游戏引擎
    
    Note over U,O: AI故事生成流程
    GE->>SP: 请求生成初始场景
    SP->>O: 发送场景生成Prompt
    O-->>SP: 返回AI生成内容
    SP-->>GE: 解析后的场景数据
    GE->>SM: 更新游戏状态
    SM-->>UI: 返回当前状态
    UI->>U: 显示场景和选项
    
    Note over U,O: 玩家交互循环
    loop 游戏主循环
        U->>UI: 输入选择
        UI->>GE: 传递玩家输入
        
        alt AI生成模式
            GE->>SP: 请求事件推进
            SP->>O: 发送事件推进Prompt
            O-->>SP: 返回事件结果
            SP-->>GE: 解析后的事件数据
            GE->>SP: 请求新场景生成
            SP->>O: 发送场景生成Prompt
            O-->>SP: 返回新场景
            SP-->>GE: 解析后的场景数据
        else 预设模式
            GE->>GE: 使用预设剧情逻辑
        end
        
        GE->>SM: 更新游戏状态
        SM->>SM: 处理状态变化
        SM-->>GE: 返回更新后状态
        GE-->>UI: 返回新场景数据
        UI->>U: 显示新场景
        
        alt 游戏结束
            UI->>U: 显示结局
            UI->>SM: 询问是否保存
            alt 保存游戏
                SM->>SM: 序列化游戏数据
                SM->>SM: 写入JSON文件
            end
        end
    end
```
1. **启动阶段**: 用户选择新游戏或继续游戏
2. **初始化阶段**: AI生成初始场景或加载存档
3. **主循环阶段**: 玩家输入 → AI生成 → 状态更新 → 显示结果
4. **结束阶段**: 保存游戏或退出

## 📊 类关系结构

**第三个图**展示了**详细的类设计**：
```mermaid
classDiagram
    class UserInterface {
        +display_scene(description)
        +display_options(options)
        +get_player_input(options)
        +show_message(msg)
    }
    
    class GameEngine {
        -scene_prompt: ScenePrompt
        -story_step: int
        -use_ai_generation: bool
        -game_theme: str
        +start_new_game(state_manager, theme)
        +next_step(player_input, state_manager)
        +generate_ai_story(player_input, state_manager)
        +generate_preset_story(player_input, state_manager)
        +process_status_changes(status_changes, state_manager)
        +add_random_game_elements(state_manager)
        +check_ending_conditions(state_manager)
        +toggle_ai_generation(enabled)
    }
    
    class GameStateManager {
        -player: Player
        -story: StoryState
        -game_metadata: Dict
        -save_directory: str
        +create_new_game(player_name)
        +update_story(scene_id, description, options, player_choice)
        +set_story_flag(flag_name, value)
        +get_story_flag(flag_name, default)
        +add_player_item(item)
        +player_gain_experience(exp)
        +get_current_state()
        +save_game(save_name)
        +load_game(save_name)
    }
    
    class Player {
        +name: str
        +level: int
        +health: int
        +max_health: int
        +experience: int
        +inventory: List[str]
        +skills: Dict[str, int]
        +add_item(item)
        +remove_item(item)
        +add_experience(exp)
        +level_up()
        +heal(amount)
        +take_damage(amount)
        +to_dict()
        +from_dict(data)
    }
    
    class StoryState {
        +current_scene_id: str
        +current_description: str
        +current_options: List[str]
        +history: List[StoryNode]
        +story_flags: Dict[str, Any]
        +is_ended: bool
        +add_scene(scene_id, description, options)
        +record_choice(choice)
        +set_flag(flag_name, value)
        +get_story_context()
        +to_dict()
        +from_dict(data)
    }
    
    class StoryNode {
        +scene_id: str
        +description: str
        +options: List[str]
        +player_choice: str
        +timestamp: datetime
        +to_dict()
        +from_dict(data)
    }
    
    class ScenePrompt {
        -llm: Ollama
        +build_scene_prompt(story_context, player_action, scene_type)
        +build_character_dialogue_prompt(character_info, dialogue_context, player_speech)
        +build_options_prompt(current_situation, story_context, difficulty)
        +build_event_progression_prompt(story_context, player_choice, previous_events)
        +generate_scene(story_context, player_action, scene_type)
        +generate_character_dialogue(character_info, dialogue_context, player_speech)
        +generate_options(current_situation, story_context, difficulty)
        +generate_event_progression(story_context, player_choice, previous_events)
        +parse_scene_response(response)
        +parse_options_response(response)
        +parse_event_response(response)
    }
    
    class Ollama {
        +model: str
        +base_url: str
        +invoke(prompt)
    }
    
    %% 关联关系
    GameEngine --> ScenePrompt
    GameEngine --> GameStateManager
    GameStateManager --> Player
    GameStateManager --> StoryState
    StoryState --> StoryNode
    ScenePrompt --> Ollama
    UserInterface ..> GameEngine : uses
    UserInterface ..> GameStateManager : uses
```
### 核心特点：
- **松耦合设计**: 各模块职责清晰，便于扩展
- **双模式支持**: AI生成 + 预设故事的混合模式
- **完整状态管理**: 玩家属性、剧情状态、存档系统
- **AI集成**: 四种提示词类型，支持复杂故事生成

### 数据流向：
```
用户输入 → GameEngine → ScenePrompt → Ollama → 解析响应 → 更新状态 → 显示结果
```

## 🎯 技术亮点

1. **AI驱动的故事生成**: 每次游玩都有不同体验
2. **容错机制**: AI失败时自动回退到预设剧情  
3. **模块化设计**: 易于扩展新功能和游戏主题
4. **完整的RPG要素**: 经验、升级、物品、随机事件
5. **灵活的存档系统**: 支持多存档管理

这个架构设计既保证了游戏的稳定性，又充分利用了AI的创造性，为玩家提供了丰富多变的游戏体验。