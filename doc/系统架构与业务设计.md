# 文字冒险游戏：系统架构与业务设计

## 1. 项目概述

本项目是一个基于大型语言模型（LLM）动态生成内容的文字冒险游戏。玩家可以创建自定义角色，在一个由AI实时创造的奇幻世界中进行探索。与传统游戏不同，本作的剧情、场景、NPC行为乃至玩家的可用选项都由语言模型动态生成，旨在提供一个真正开放、不可预测的沉浸式叙事体验。

项目采用Python作为主要开发语言，结合LangChain框架与Ollama在本机部署的语言模型进行交互，并使用Streamlit构建了一个现代、简洁的Web用户界面。

## 2. 业务流程

游戏的核心业务流程围绕着玩家的单次行动（Turn）展开，形成一个闭环，驱动故事不断向前发展。

![业务流程图](https://mermaid.ink/svg/pako:eNqVVMtqwzAQ_BXLl6apG3fcoUMfKIVSCqFAH7rYJtYSO7ZtJQX9965zOqFNL1Is787O7M6s5lOaAFo4JqWlXoG0C6JNx_P2sWj_mS20pDacE8Z5mS1d8Z4yT-u9y7W8k03n2w-hFzSg_Y4tC0N4t0Y987QnJ46d2vL8lM_W2E6rS55w3r7Qz1LqR59Wl6nU1k3h2bUaV5R2M8LhC5kHlQ88wBfT4gW23K_7uR2Xy7_Q2y27zVwVd-pS2x7-4QdG2qP25zO5bL9-G6mQ3fV0b0q19zT2QvLz73_Q5yS5q8jO0bIay1L3o4E3tA45VpL5hJ0iWnQ0eQoD2QdKUk59gZl3v04Z3dK99sKqT1jGgYFqR4mBf2I6UoFj2oQ0s0L4lR9wZ5y5o4LllQGKW2cQjFzOQZtYy_oYjWq5lGMaOQ7n5nBq9Z6D3Z_h8T5b-U9R_0KzGjY0WImhKxI_Wp1I8L1U7OQ8-q-3r41D17qG8R_JtQ-A)

```mermaid
graph TD
    A[用户进入应用] --> B{输入角色名/背景故事};
    B --> C[点击 "开始新游戏"];
    C --> D[系统: 初始化游戏状态 (StoryState)];
    D --> E[系统: 调用LLM生成初始场景];
    E --> F[UI: 显示场景描述、玩家状态和选项按钮];
    F --> G{玩家点击一个选项};
    G --> H[系统: 处理玩家选择];
    H --> I[系统: 调用LLM生成新场景和选项];
    I --> J[系统: 更新并保存游戏状态];
    J --> F;
```

1.  **游戏启动**：用户打开Web应用，输入角色的名字和背景故事。
2.  **创建世界**：点击"开始新游戏"后，系统将用户输入作为初始上下文，调用LLM生成游戏的开篇场景和初始选项。
3.  **核心循环**：
    *   UI层展示当前场景描述、玩家状态和AI生成的选项。
    *   玩家从选项中选择一项。
    *   游戏引擎将玩家的选择作为新的输入，再次调用LLM。
    *   LLM根据新的输入，生成后续的剧情、场景变化以及新的选项。
    *   系统更新游戏状态（如玩家属性变化、故事进展），并持久化保存。
    *   UI刷新，向玩家展示新的世界状态。
4.  **持续演进**：此循环不断重复，构成一个动态、持续发展的冒险故事。

## 3. 技术架构

项目采用模块化设计，将用户界面、游戏逻辑和LLM交互清晰地分离，以提高代码的可维护性和扩展性。

### 3.1. 总体架构图

![技术架构图](https://mermaid.ink/svg/pako:eNqVVktuwyAQ_BXLF6m7DuqGA-yxx55KbVIv0iUXZhybWIEdO0qK_fdK2DQp9dYSCXnezsw-O1mNaAFN0aD8yS2hVd10m_T2-LHt-pWnS-eG7b-hR7Zq_R1n7V4HlS5tWk6y_5cR6sW9DweV1lG_5u6qYvj5lHl7y-n7o_pQ58X5vJ4293f7W1zM-J1g42V07A2rI1_O84lVp9t7pQ6G8dG-i6C218c5R2q_J1gQeU7oVf-cTq-I3tFz2mU-Oq4xL-z26_G61v_5bA8nF6m5e3jV84-0B5S2Wl5n7S4Jc2k5zD4X2mI9x47G21K16p10xQc-Wd9R4T_9wB_J7G34_wB7_9B_oJ-M9_T_V-uA8e2N22M05FkK4Xn2y8Wn0_G14hM563v-zWb9-cQfKxWq8k)

```mermaid
graph TD
    subgraph "用户界面 (Streamlit)"
        A[app.py]
    end

    subgraph "游戏核心逻辑"
        B[game_engine.py]
        C[state_manager.py]
        D[models/]
    end

    subgraph "LLM 交互层 (LangChain)"
        E[langchain_chain.py]
        F[prompts/scene_prompt.py]
        G[output_parser.py]
        H[LLM (Ollama)]
    end

    subgraph "配置与数据"
        I[config.json]
        J[saves/]
    end

    A -- 用户操作 --> B
    B -- 更新/获取状态 --> C
    C -- 读/写 --> J
    C -- 依赖 --> D
    B -- 请求内容生成 --> E
    E -- 构造Prompt --> F
    E -- 调用 --> H
    H -- 返回JSON字符串 --> E
    E -- 解析 --> G
    G -- 返回结构化数据 --> E
    E -- 返回场景/选项 --> B
    B -- 渲染 --> A
    E -- 读取配置 --> I
```

### 3.2. 核心数据流 (一次玩家行动)

当玩家在UI上点击一个选项按钮后，系统内部会发生以下一系列事件：

1.  **UI 事件捕获 (`app.py`)**: Streamlit捕捉到按钮点击事件，获取该选项关联的`option_event`。
2.  **调用游戏引擎 (`app.py`)**: 调用`game_engine.run_one_turn()`，将`option_event`作为参数传入。
3.  **内容生成 (`game_engine.py` -> `langchain_chain.py`)**:
    *   游戏引擎请求LLM交互层生成新场景。
    *   `langchain_chain.get_scene()`使用`prompts/scene_prompt.py`中的模板，结合当前的游戏状态和玩家选择，构建一个完整的Prompt。
    *   通过LangChain的`RunnableSequence`将Prompt发送给Ollama LLM。
4.  **解析与结构化 (`output_parser.py`)**:
    *   LLM返回一个包含新场景信息的JSON格式字符串。
    *   `output_parser.parse_scene()`负责将这个JSON字符串解析并转换为强类型的`StoryState` Python对象。
5.  **状态更新 (`game_engine.py` -> `state_manager.py`)**:
    *   游戏引擎接收到新的`StoryState`对象，并用它来更新当前的游戏状态。
    *   `state_manager.save_game()`被调用，将更新后的完整游戏状态序列化为JSON文件，覆盖保存在`saves/`目录中的存档。
6.  **UI 刷新 (`app.py`)**: `st.rerun()`被调用，强制Streamlit重新执行脚本。UI重新从存档中读取最新的游戏状态，并渲染出新的场景描述和选项，完成一次完整的交互闭环。

### 3.3. 关键模块说明

-   **`app.py`**: **Web界面**。基于Streamlit构建，负责所有用户交互，包括展示游戏场景、渲染选项按钮、接收用户输入以及驱动游戏主循环。
-   **`game_engine.py`**: **游戏引擎**。封装了游戏的核心逻辑，协调UI、状态管理和LLM交互层，定义了`run_one_turn`等核心行为。
-   **`state_manager.py`**: **状态管理器**。负责游戏的加载和保存。它将`StoryState`对象序列化到`saves/`目录下的JSON文件，并在应用启动或刷新时重新加载，实现了游戏状态的持久化。
-   **`langchain_chain.py`**: **LLM交互层**。封装了所有与语言模型的通信细节。它从`config.json`读取模型配置，使用LangChain构建调用链，并整合Prompt模板和输出解析器。
-   **`prompts/scene_prompt.py`**: **Prompt工程核心**。定义了与LLM沟通的模板。这是决定生成内容质量的关键，其中包含场景生成的指令、JSON输出格式的强制要求，以及一个高质量的"Few-shot"示例，用于引导LLM产出符合预期的、富有创造力的内容。
-   **`output_parser.py`**: **输出解析器**。提供健壮的JSON解析功能，能处理LLM可能返回的不规范或包含额外文本（如Markdown标记）的JSON字符串，确保数据处理的稳定性。
-   **`models/`**: **数据模型**。定义了`Player`和`StoryState`等核心数据结构，为游戏状态提供了清晰、强类型的定义。
-   **`config.json`**: **配置文件**。将Ollama模型的地址（URL）和模型名称（Model Name）外部化，使得用户无需修改代码即可轻松切换或指定不同的语言模型。

## 4. 核心设计深度解析

### 4.1. Prompt 工程

Prompt的设计是本项目成功的基石。我们没有使用简单的单句指令，而是构建了一个结构化的、包含多重指令的复杂Prompt，其关键设计点如下：

-   **角色扮演指令**: 明确要求LLM扮演"富有想象力的文字冒险游戏引擎"的角色。
-   **JSON格式强制**: 严格规定输出必须是JSON格式，并定义了`scene_description`、`player_options`等关键字段，便于程序解析。
-   **动态上下文注入**: 将玩家的背景故事、当前状态和最近的行动动态地插入到Prompt中，为LLM提供充分的上下文。
-   **"Few-shot" 示例**: 在Prompt中提供了一个完整、高质量的请求-响应示例。这个示例不仅展示了期望的JSON结构，更重要的是，它通过具体内容（如富有文采的场景描述和有趣的选项）为LLM的创造力设定了一个高标准，有效避免了生成重复、无趣或敷衍内容的倾向。

### 4.2. 状态管理机制

项目的状态管理分为两个层面：

1.  **内存状态 (`st.session_state`)**: Streamlit的`session_state`用于在用户的单次会话中持有游戏状态对象。这避免了每次交互都从磁盘读取文件，提高了响应速度。
2.  **持久化存储 (`saves/`)**: 每次玩家行动后，最新的游戏状态都会被`state_manager`序列化为JSON文件并保存到`saves/`目录。这确保了即使关闭浏览器或应用重启，游戏进度也不会丢失。文件名通常与玩家姓名关联。

这种设计兼顾了性能和数据的持久性。

## 5. 未来展望

本项目已经构建了一个稳固且可玩的核心框架，未来可以从以下几个方向进行扩展：

-   **多模态体验**: 集成图像生成模型（如Stable Diffusion），为每个场景动态生成配图，提升沉浸感。
-   **更丰富的游戏系统**: 引入复杂的库存管理、技能树、NPC好感度等系统，增加游戏的可玩性。
-   **存档管理系统**: 在UI上提供创建、加载、删除多个存档的功能。
-   **Prompt 链与Agent化**: 针对特定任务（如战斗、解谜）设计专用的Prompt链，甚至引入LangChain Agent，让游戏能够根据场景自动选择最合适的工具或逻辑链，实现更复杂的交互。
-   **声音与音乐**: 集成TTS（文本转语音）和动态音效，打造听觉体验。 